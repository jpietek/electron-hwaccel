diff --git a/components/viz/service/display_embedder/skia_output_device_offscreen.cc b/components/viz/service/display_embedder/skia_output_device_offscreen.cc
index f665cfac5ff18..4ce815eda3d84 100644
--- a/components/viz/service/display_embedder/skia_output_device_offscreen.cc
+++ b/components/viz/service/display_embedder/skia_output_device_offscreen.cc
@@ -88,6 +88,19 @@ void SkiaOutputDeviceOffscreen::Present(
   // Reshape should have been called first.
   DCHECK(backend_texture_.isValid() || graphite_texture_.isValid());
 
+  // Capture swap-start as early as possible for offscreen ack.
+  const base::TimeTicks swap_start = base::TimeTicks::Now();
+
+  // If using GL-backed Ganesh offscreen texture and a hook is provided, emit
+  // the GLuint along with the swap-start time.
+  if (offscreen_gl_present_hook_ && backend_texture_.isValid() &&
+      backend_texture_.backend() == GrBackendApi::kOpenGL) {
+    GrGLTextureInfo tex_info;
+    if (GrBackendTextures::GetGLTextureInfo(backend_texture_, &tex_info)) {
+      offscreen_gl_present_hook_.Run(static_cast<GrGLuint>(tex_info.fID), swap_start);
+    }
+  }
+
   StartSwapBuffers(std::move(feedback));
   FinishSwapBuffers(gfx::SwapCompletionResult(gfx::SwapResult::SWAP_ACK),
                     gfx::Size(size_.width(), size_.height()), std::move(frame));
diff --git a/components/viz/service/display_embedder/skia_output_device_offscreen.h b/components/viz/service/display_embedder/skia_output_device_offscreen.h
index 63823822a3963..06f3172ee0be2 100644
--- a/components/viz/service/display_embedder/skia_output_device_offscreen.h
+++ b/components/viz/service/display_embedder/skia_output_device_offscreen.h
@@ -12,6 +12,9 @@
 #include "third_party/skia/include/core/SkColorSpace.h"
 #include "third_party/skia/include/core/SkImageInfo.h"
 #include "third_party/skia/include/gpu/graphite/BackendTexture.h"
+#include "third_party/skia/include/gpu/ganesh/gl/GrGLTypes.h"
+#include "base/functional/callback.h"
+#include "base/time/time.h"
 
 namespace viz {
 
@@ -42,6 +45,14 @@ class SkiaOutputDeviceOffscreen : public SkiaOutputDevice {
   void EndPaint() override;
   void ReadbackForTesting(base::OnceCallback<void(SkBitmap)> callback) override;
 
+  // Hook for strictly offscreen GL path to obtain the GL texture id and the
+  // corresponding swap-start timestamp just before acknowledging the swap.
+  using OffscreenGlPresentHook =
+      base::RepeatingCallback<void(GrGLuint /*texture_id*/, base::TimeTicks /*swap_start*/)>;
+  void SetOffscreenGlPresentHook(OffscreenGlPresentHook hook) {
+    offscreen_gl_present_hook_ = std::move(hook);
+  }
+
  protected:
   scoped_refptr<gpu::SharedContextState> context_state_;
   const bool has_alpha_;
@@ -56,6 +67,7 @@ class SkiaOutputDeviceOffscreen : public SkiaOutputDevice {
 
  private:
   uint64_t backbuffer_estimated_size_ = 0;
+  OffscreenGlPresentHook offscreen_gl_present_hook_;
 };
 
 }  // namespace viz
diff --git a/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc b/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
index 370f9ef85e95b..a395026827f79 100644
--- a/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
+++ b/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
@@ -95,6 +95,8 @@
 #include "ui/gl/gl_surface.h"
 #include "ui/gl/presenter.h"
 #include "ui/gl/progress_reporter.h"
+#include "ui/gl/gl_bindings.h"
+#include "ui/gl/gl_context.h"
 #include "url/gurl.h"
 
 #if BUILDFLAG(IS_WIN)
@@ -134,8 +136,21 @@
 #include "components/viz/service/display_embedder/output_presenter_fuchsia.h"
 #endif
 
+#define CUDA_INIT_OPENGL
+#include "cuda_loader/cuda_wrapper_include.h"
+
 namespace viz {
 
+bool cuda_init = false;
+
+CUcontext cu_ctx;
+size_t cuda_memory_width = 3840; 
+size_t cuda_memory_height = 2160;
+CUdeviceptr cuda_memory;
+CUipcMemHandle ipc_handle;
+CUgraphicsResource cuda_resource;
+CUarray cuda_array;
+
 namespace {
 
 template <typename... Args>
@@ -144,7 +159,7 @@ void PostAsyncTaskRepeatedly(
     const base::RepeatingCallback<void(Args...)>& callback,
     Args... args) {
   // Callbacks generated by this function may be executed asynchronously
-  // (e.g. by presentation feedback) after |impl_on_gpu| has been destroyed.
+  // (e.g. by presentation feedback) after |impl_on_pu| has been destroyed.
   if (impl_on_gpu) {
     impl_on_gpu->PostTaskToClientThread(base::BindOnce(callback, args...));
   }
@@ -1957,6 +1972,139 @@ bool SkiaOutputSurfaceImplOnGpu::InitializeForGL() {
         renderer_settings_.requires_alpha_channel,
         shared_gpu_deps_->memory_tracker(),
         GetDidSwapBuffersCompleteCallback());
+
+    // Sample hook: print GL texture id and swap-start time for strictly offscreen GL.
+    static_cast<SkiaOutputDeviceOffscreen*>(output_device_.get())
+        ->SetOffscreenGlPresentHook(base::BindRepeating(
+            [](GrGLuint texture_id, base::TimeTicks swap_start) {
+              fprintf(stdout, "[CudaOffscreenHook] tex=%u, swap_start(us)=%lld\n",
+                      static_cast<unsigned>(texture_id),
+                      static_cast<long long>(
+                          (swap_start - base::TimeTicks()).InMicroseconds()));
+
+              if (!cuda_init) {
+                CUresult status = cuInit_drvapi(0, __CUDA_API_VERSION);
+                if (CUDA_SUCCESS != status) {
+                  fprintf(stdout, "[CudaOffscreenHook] cuda init failed");
+                  return;
+                }
+
+		int dev_count;
+		CHECK_CU(cuDeviceGetCount(&dev_count));
+                fprintf(stdout, "[CudaOffscreenHook] cu dev count %u", dev_count);
+		if (!dev_count) {
+                   fprintf(stdout, "[CudaOffscreenHook] no cuda device present");
+		   return;
+		}
+		CUdevice device = 0;
+		CHECK_CU(cuDeviceGet(&device, 0));
+
+		char name[128] = {};
+		CHECK_CU(cuDeviceGetName(name, sizeof(name), device));
+
+		fprintf(stdout, "[CudaOffscreenHook] device_ordinal=%d device_count=%d device_name=%s",
+		   static_cast<int>(device), dev_count, name);
+		fflush(stdout);
+
+		CHECK_CU(cuCtxCreate(&cu_ctx, 0, device));
+		int current_dev = -1;
+		CHECK_CU(cuCtxGetDevice(&current_dev));
+		fprintf(stdout, "[CudaOffscreenHook] current_ctx_device=%d\n", current_dev);
+		fflush(stdout);
+
+                CHECK_CU(cuMemAlloc(&cuda_memory, cuda_memory_width * cuda_memory_height * 4));
+                CHECK_CU(cuIpcGetMemHandle(&ipc_handle, cuda_memory));
+
+                cuda_init = true;
+                fprintf(stdout, "[CudaOffscreenHook] cuda init ok");
+                fflush(stdout);
+              }
+
+	    // Ensure CUDA context is current and compute copy dimensions from source array
+            //CHECK_CU(cuCtxSetCurrent(cu_ctx));
+	    CUcontext prev = nullptr;
+	    CHECK_CU(cuCtxGetCurrent(&prev));
+	    fprintf(stdout, "[CudaOffscreenHook] prev cu context %p %p", prev, cu_ctx);
+
+            glBindTexture(GL_TEXTURE_2D, texture_id);
+            GLint w = 0, h = 0;
+            glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &w);
+            glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &h);
+	    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
+	    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+	    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	    GLint base_level = 0, max_level = 0;
+            glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, &base_level);
+            glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, &max_level);
+            fprintf(stdout, "[CudaOffscreenHook] gl texture size %d %d [base=%d max=%d]", w, h, base_level, max_level);
+
+	    fprintf(stdout, "GL_VENDOR   : %s\n", glGetString(GL_VENDOR));
+	    fprintf(stdout, "GL_RENDERER : %s\n", glGetString(GL_RENDERER));
+	    fprintf(stdout, "GL_VERSION  : %s\n", glGetString(GL_VERSION));
+
+	    GLint internalFormat = 0;
+	    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_INTERNAL_FORMAT, &internalFormat);
+	    fprintf(stdout, "GL internal format = 0x%x\n", internalFormat);
+
+	    GLint target = 0;
+            glGetIntegerv(GL_TEXTURE_BINDING_2D_MULTISAMPLE, &target);
+	    if (target == (GLint)texture_id) {
+               fprintf(stdout, "Texture %u is bound as GL_TEXTURE_2D_MULTISAMPLE\n", texture_id);
+	    }
+
+	    fprintf(stdout, "GL texture ID=%u passed to CUDA\n", texture_id);
+
+	    CHECK_CU(cuGraphicsGLRegisterImage(&cuda_resource, texture_id, GL_TEXTURE_2D, CU_GRAPHICS_REGISTER_FLAGS_NONE));
+	    CHECK_CU(cuGraphicsMapResources(1, &cuda_resource, 0));
+	    GLenum err;
+	    err =glGetError();
+	    if (err != GL_NO_ERROR) {
+               fprintf(stdout, "gl error 0x%x", err);
+	    }
+
+            CHECK_CU(cuGraphicsSubResourceGetMappedArray(&cuda_array, cuda_resource, 0, 0));
+	    err = glGetError();
+	    if (err != GL_NO_ERROR) {
+               fprintf(stdout, "gl error 0x%x", err);
+	    }
+             
+            CUDA_ARRAY_DESCRIPTOR desc;
+            if (CHECK_CU(cuArrayGetDescriptor(&desc, cuda_array))) {
+              fprintf(stdout, "[CudaOffscreenHook] failed to get array descriptor\n");
+              CHECK_CU(cuGraphicsUnmapResources(1, &cuda_resource, 0));
+              return;
+            }
+            fprintf(stdout,
+                 "[CudaOffscreenHook] desc.Width=%u desc.Height=%u desc.Format=%d desc.NumChannels=%u\n",
+                 desc.Width, desc.Height, static_cast<int>(desc.Format),
+                 desc.NumChannels);
+             fflush(stdout);
+
+	      CUDA_MEMCPY2D cpy = {
+                 .srcMemoryType = CU_MEMORYTYPE_ARRAY,
+                 .srcArray = cuda_array,
+
+                 .dstMemoryType = CU_MEMORYTYPE_DEVICE,
+                 .dstDevice = cuda_memory,
+		 .dstPitch = cuda_memory_width * 4,
+
+                 .WidthInBytes = desc.Width * 4,
+                 .Height = desc.Height
+            };
+
+            CUstream stream;
+            CHECK_CU(cuStreamCreate(&stream, 0));
+	    CHECK_CU(cuMemcpy2DAsync(&cpy, stream));
+            CHECK_CU(cuStreamSynchronize(stream));
+            CHECK_CU(cuStreamDestroy(stream));
+
+	    CHECK_CU(cuGraphicsUnmapResources(1, &cuda_resource, 0));
+	    cuGraphicsUnregisterResource(cuda_resource);
+            fprintf(stdout, "[CudaOffscreenHook] memcpy ok");
+            fflush(stdout);
+              
+            }));
   } else {
     scoped_refptr<gl::Presenter> presenter = dependency_->CreatePresenter();
     presenter_ = presenter.get();
diff --git a/ui/gfx/linux/gpu_memory_buffer_support_x11.cc b/ui/gfx/linux/gpu_memory_buffer_support_x11.cc
index 3cea47cc7de4c..06a8026931711 100644
--- a/ui/gfx/linux/gpu_memory_buffer_support_x11.cc
+++ b/ui/gfx/linux/gpu_memory_buffer_support_x11.cc
@@ -33,33 +33,40 @@ namespace {
 // Obtain an authenticated DRM fd from X11 and create a GbmDevice with it.
 std::unique_ptr<ui::GbmDevice> CreateX11GbmDevice() {
   if (getenv("RUNNING_UNDER_RR") != nullptr) {
-    LOG(WARNING) << "Running under rr, disabling dri3";
+    LOG(ERROR) << "Running under rr, disabling dri3";
     return nullptr;
   }
 
   auto* connection = x11::Connection::Get();
   // |connection| may be nullptr in headless mode.
   if (!connection) {
-    LOG(WARNING) << "Could not create x11 connection.";
+    LOG(ERROR) << "Could not create x11 connection.";
     return nullptr;
   }
+  LOG(ERROR) << "after x11 connection";
 
   auto& dri3 = connection->dri3();
   if (!dri3.present()) {
-    LOG(WARNING) << "dri3 extension not supported.";
+    LOG(ERROR) << "dri3 extension not supported.";
     return nullptr;
   }
 
+  LOG(ERROR) << "after dri3 extension";
+
   // Obtain an authenticated DRM fd.
   auto reply = dri3.Open({connection->default_root(), 0}).Sync();
-  if (!reply)
+  if (!reply) {
+    LOG(ERROR) << "dri3 open failed";
     return nullptr;
-
+  }
   base::ScopedFD fd(HANDLE_EINTR(dup(reply->device_fd.get())));
   if (!fd.is_valid())
+    LOG(ERROR) << "dri3 failed to get valid fd";
     return nullptr;
-  if (HANDLE_EINTR(fcntl(fd.get(), F_SETFD, FD_CLOEXEC)) == -1)
+  if (HANDLE_EINTR(fcntl(fd.get(), F_SETFD, FD_CLOEXEC)) == -1) {
+    LOG(ERROR) << "dri3 failed to get valid fd";
     return nullptr;
+  }
 
   return ui::CreateGbmDevice(fd.release());
 }
